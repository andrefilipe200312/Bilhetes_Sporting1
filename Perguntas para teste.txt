
a) Compare e contraste sensores de dist√¢ncia por ultrassom (US) versus sensores de dist√¢ncia por infravermelho (IR).

Discuta como cada um lida com materiais ‚Äúdif√≠ceis‚Äù, referenciando especificamente como reagem a superf√≠cies pretas foscas e a tecidos que absorvem som.

Princ√≠pio de funcionamento:
Sensores US emitem ondas de press√£o (som) e medem o Tempo de Voo (Time-of-Flight, ToF) para calcular a dist√¢ncia.
Sensores IR normalmente usam a intensidade da luz refletida ou triangula√ß√£o (embora os slides enfatizem que US usa ToF e IR usa luz).

Resposta a materiais ‚Äúdif√≠ceis‚Äù:

Tecidos que absorvem som: Sensores US t√™m dificuldade porque os tecidos absorvem as ondas sonoras, impedindo que o eco retorne ao sensor. Sensores IR provavelmente detectariam o tecido se ele for opaco.

Superf√≠cies pretas foscas: Embora n√£o seja explicitamente detalhado no texto, os slides indicam que sensores US s√£o sens√≠veis ao tipo de material. Em geral, em contextos de rob√≥tica, sensores IR falham em superf√≠cies pretas porque elas absorvem a luz, enquanto sensores US funcionam bem em superf√≠cies pretas, pois a cor n√£o afeta a reflex√£o do som.

Exatid√£o (Accuracy) e Precis√£o (Precision)

Defina os conceitos de Exatid√£o e Precis√£o no contexto de sensores rob√≥ticos. Esboce um gr√°fico de densidade de probabilidade representando um sensor que √© altamente preciso, mas com baixa exatid√£o em rela√ß√£o a um valor de refer√™ncia verdadeiro.

Defini√ß√µes:

Exatid√£o (Accuracy): Proximidade de uma medi√ß√£o em rela√ß√£o ao valor f√≠sico verdadeiro (impl√≠cito no contexto de ‚ÄúCalibra√ß√£o‚Äù e do mapeamento de valores do sensor para grandezas f√≠sicas).

Precis√£o (ou Confiabilidade): Capacidade do sensor de fornecer resultados consistentes sob as mesmas condi√ß√µes. Est√° relacionada √† vari√¢ncia estat√≠stica das leituras do sensor.

Sensor Time-of-Flight (ToF)

Um rob√¥ utiliza um sensor Time-of-Flight (ToF). Se o sensor emite um pulso e recebe a resposta ap√≥s 2,55 ms, calcule a dist√¢ncia at√© o obst√°culo.
(Assuma a velocidade do som como 343 m/s para US ou 3√ó10‚Å∏ m/s para luz, declarando claramente qual suposi√ß√£o est√° sendo usada com base no tipo de sensor).

Regra de tr√™s simples e dividir por dois devido ao ECO.

Estabilidade Est√°tica vs. Estabilidade Din√¢mica

Explique a diferen√ßa entre estabilidade est√°tica e estabilidade din√¢mica na locomo√ß√£o. Forne√ßa um exemplo de um rob√¥ (ou ve√≠culo) que depende de estabilidade din√¢mica para permanecer em p√© e explique o mecanismo (por exemplo, ZMP ou compensa√ß√£o ativa) que evita a queda.

Estabilidade Est√°tica: O rob√¥ √© est√°vel se o seu centro de massa cair dentro do pol√≠gono definido pelos pontos de apoio enquanto o corpo est√° parado.

Estabilidade Din√¢mica: Propriedade de um corpo de compensar perturba√ß√µes de equil√≠brio enquanto est√° em movimento, mesmo que n√£o seja estaticamente est√°vel.

Exemplo: Um rob√¥ b√≠pede andando (como o mostrado nos slides usando ZMP ‚Äì Zero Moment Point). Durante a caminhada, o centro de massa frequentemente projeta-se fora da base de suporte, mas o rob√¥ evita cair por meio de compensa√ß√£o ativa e do uso do momento.

Sensores Ativos vs. Passivos

Explique a diferen√ßa fundamental entre sensores ativos e passivos. Forne√ßa um exemplo de sensor ativo usado para medi√ß√£o de dist√¢ncia e um exemplo de sensor passivo usado para propriocep√ß√£o.

Solu√ß√£o:
Sensores passivos medem energia que √© naturalmente gerada pelo ambiente (por exemplo, uma c√¢mera captando luz solar refletida ou um microfone captando som).
Sensores ativos emitem sua pr√≥pria energia no ambiente e medem a rea√ß√£o/reflex√£o.

Exemplos:

Ativos: Ultrassom, LIDAR, Proximidade por Infravermelho.

Passivos: C√¢meras (CCD/CMOS), Microfones, Sensores piezoel√©tricos.

Propriocep√ß√£o vs. Exterocep√ß√£o

Solu√ß√£o:

i) Encoder de roda: Proprioceptivo. Mede o estado interno do rob√¥ (rota√ß√£o da roda/√¢ngulo da junta), n√£o o ambiente externo.

ii) LIDAR: Exteroceptivo. Mede a dist√¢ncia at√© objetos externos, percebendo o ambiente.

Encoders: Incrementais vs. Absolutos

Solu√ß√£o:
Um encoder incremental conta transi√ß√µes (pulsos) relativas a um ponto inicial; se a energia for perdida, a contagem √© perdida e √© necess√°rio um procedimento de ‚Äúhoming‚Äù para restabelecer a refer√™ncia.
Um encoder absoluto possui um padr√£o √∫nico (c√≥digo) para cada √¢ngulo espec√≠fico, conhecendo sua posi√ß√£o exata imediatamente ao ligar, sem necessidade de movimento.

Ru√≠do de Sinal e Filtragem (SMA)

Solu√ß√£o:

F√≥rmula:
SMA‚Çñ = (1/k) ‚àë·µ¢‚Çå‚Çô‚Çã‚Çñ‚Çä‚ÇÅ‚Åø p·µ¢ (m√©dia das √∫ltimas k medi√ß√µes)

Compromisso (trade-off):
Um k grande fornece um sinal mais suave (filtra mais ru√≠do), mas introduz atraso significativo na resposta do sistema.
Um k pequeno √© mais responsivo (menos atraso), mas filtra menos ru√≠do.

Tecnologia LIDAR

Solu√ß√£o:
LIDAR (Light Detection and Ranging) emite pulsos de laser e mede o Tempo de Voo (ToF) para a luz retornar. Ao girar o emissor/receptor usando um espelho ou motor, ele varre um plano horizontal, criando uma ‚Äúfatia‚Äù 2D ou mapa de dist√¢ncias aos obst√°culos no ambiente.

Modelo de C√¢mera Pinhole

Solu√ß√£o:
No modelo pinhole, a luz passa por uma pequena abertura. A rela√ß√£o √© de similaridade geom√©trica:

y / y‚Ä≤ = x‚ÇÄ / x·µ¢

x·µ¢: dist√¢ncia do pinhole ao plano da imagem (dist√¢ncia focal).

x‚ÇÄ: dist√¢ncia do pinhole ao objeto.

y‚Ä≤: tamanho projetado do objeto no plano da imagem.

A imagem formada √© invertida.

Caracter√≠sticas de Vis√£o Computacional: Fluxo √ìptico

Solu√ß√£o:
Fluxo √≥ptico √© o padr√£o de movimento aparente de objetos na imagem entre dois frames consecutivos, causado pelo movimento do objeto ou da c√¢mera.
Um rob√¥ m√≥vel pode us√°-lo para estimar sua pr√≥pria velocidade (egomotion) em rela√ß√£o ao ambiente est√°tico ou para detectar obst√°culos em movimento.

Rob√≥tica Probabil√≠stica: Diagn√≥stico vs. Causal

Causal (P(z | x)): Probabilidade de observar a medi√ß√£o z dado que o rob√¥ est√° no estado x (por exemplo: ‚ÄúDado que estou em frente a uma porta, o que o sensor v√™?‚Äù). Geralmente √© mais f√°cil de modelar fisicamente.

Diagn√≥stico (P(x | z)): Probabilidade de o rob√¥ estar no estado x dado que observou a medi√ß√£o z (por exemplo: ‚ÄúVejo uma porta, estou no corredor?‚Äù).

Regra de Bayes: Permite converter modelos causais em estimativas diagn√≥sticas:
P(x | z) = P(z | x) P(x) / P(z)

Filtro de Kalman: Predi√ß√£o vs. Atualiza√ß√£o

Predi√ß√£o (Atualiza√ß√£o Temporal): O rob√¥ estima sua nova posi√ß√£o com base nos comandos de movimento (u‚Çñ‚Çã‚ÇÅ). A incerteza (covari√¢ncia P‚Çñ‚Åª) aumenta devido ao ru√≠do do processo (Q).

Atualiza√ß√£o (Corre√ß√£o): O rob√¥ combina a predi√ß√£o com dados dos sensores (z‚Çñ). A incerteza (covari√¢ncia P‚Çñ) diminui porque o sensor fornece informa√ß√£o que restringe a estimativa.

SLAM

Solu√ß√£o:
SLAM (Localiza√ß√£o e Mapeamento Simult√¢neos) √© o processo em que um rob√¥ constr√≥i um mapa de um ambiente desconhecido enquanto simultaneamente estima sua pr√≥pria posi√ß√£o nesse mapa. √â um problema de ‚Äúovo e galinha‚Äù, pois a localiza√ß√£o precisa requer um mapa, mas a constru√ß√£o de um mapa consistente requer localiza√ß√£o precisa.

Malha Aberta vs. Malha Fechada

Solu√ß√£o:

Malha Aberta: Controlador ‚Üí Atuador ‚Üí Sistema (sem realimenta√ß√£o).

Malha Fechada: Controlador ‚Üí Atuador ‚Üí Sistema ‚Üí Sensor ‚Üí Controlador (com realimenta√ß√£o).

O sensor na malha fechada fornece o sinal de sa√≠da y(t), que √© comparado com a refer√™ncia r(t), permitindo ao controlador calcular o erro e(t) e corrigir desvios.

Controle PID (Proporcional)

Solu√ß√£o:

Efeito: A sa√≠da √© proporcional ao erro atual (u(t) = K‚Çö e(t)).

K‚Çö baixo: O sistema responde lentamente e pode nunca atingir o alvo devido ao atrito (erro em regime permanente).

K‚Çö alto: O sistema reage rapidamente, mas pode ultrapassar o alvo e oscilar (comportamento subamortecido).

Controle PID (Integral)

Solu√ß√£o:
Um controlador P pode fornecer corre√ß√£o zero quando o erro √© pequeno, deixando o rob√¥ pr√≥ximo, mas n√£o exatamente no alvo (erro em regime permanente).
O termo Integral (K·µ¢) soma os pequenos erros passados ao longo do tempo at√© que o termo acumulado seja grande o suficiente para eliminar esse erro.

Controle PID (Derivativo)

Solu√ß√£o:

Fun√ß√£o: Kùíπ reage √† taxa de varia√ß√£o do erro, atuando como um amortecedor ou freio para evitar overshoot.

Efeito negativo: Se o sinal do sensor tiver ru√≠do de alta frequ√™ncia, o termo derivativo amplifica esse ru√≠do, causando tremores ou instabilidade nos atuadores.

Holonomia

Solu√ß√£o:
Um rob√¥ holonomico √© aquele em que o n√∫mero de graus de liberdade control√°veis √© igual ao n√∫mero total de graus de liberdade no plano (3 em 2D: x, y, Œ∏).

Carro (Ackermann): N√£o-holon√¥mico. Possui 2 graus de liberdade control√°veis (velocidade e dire√ß√£o), mas move-se em um espa√ßo de configura√ß√£o 3D (x, y, Œ∏). N√£o pode mover-se lateralmente instantaneamente; precisa realizar manobras.

Cinem√°tica de Locomo√ß√£o (Tra√ß√£o Diferencial)

Solu√ß√£o:
A velocidade angular œâ depende da diferen√ßa entre as velocidades das rodas direita e esquerda (v·¥ø, v·¥∏) e da dist√¢ncia entre elas (d):

œâ = (v·¥ø ‚àí v·¥∏) / d

Estabilidade e ZMP

Solu√ß√£o:
ZMP (Zero Moment Point) √© o ponto no solo onde o resultante das for√ßas de gravidade e in√©rcia n√£o gera momento horizontal.
Para que um rob√¥ mantenha estabilidade din√¢mica (por exemplo, um b√≠pede andando), o ZMP deve permanecer estritamente dentro do pol√≠gono de suporte (a √°rea dos p√©s), mesmo que o centro de massa projete-se fora dele.

Navega√ß√£o vs. Pilotagem

Solu√ß√£o:

Navega√ß√£o: Planejamento global usando mapas para encontrar caminhos √≥timos at√© um objetivo distante (por exemplo, algoritmo A*).

Pilotagem: Movimento local e reativo lidando com obst√°culos imediatos e imprevistos (por exemplo, seguir paredes, evitar obst√°culos).

Planejamento de Caminho (Algoritmos Bug)

Solu√ß√£o:

Bug 1: Exaustivo. Contorna todo o obst√°culo para encontrar o ponto mais pr√≥ximo do objetivo antes de sair. √â mais lento, por√©m confi√°vel.

Bug 2: Guloso. Segue o obst√°culo apenas at√© cruzar novamente a ‚Äúm-line‚Äù (linha do in√≠cio ao objetivo) mais pr√≥ximo do objetivo. Normalmente √© mais r√°pido, mas pode ser menos eficiente em labirintos ou espirais.

RRT (Rapidly-exploring Random Trees)

Solu√ß√£o:
RRT explora o espa√ßo amostrando aleatoriamente um ponto no espa√ßo de configura√ß√£o e estendendo o n√≥ mais pr√≥ximo da √°rvore em dire√ß√£o a esse ponto por um pequeno passo. Isso permite explorar rapidamente espa√ßos grandes e de alta dimensionalidade sem construir uma grade densa ou um mapa geom√©trico completo.

Arquiteturas Funcionais vs. Comportamentais

Solu√ß√£o:

Cr√≠tica: Arquiteturas funcionais usam um ciclo serial Perceber ‚Üí Modelar ‚Üí Planejar ‚Üí Agir.

Paradoxo: Sensores s√£o ruidosos e o mundo √© complexo e din√¢mico. Construir um modelo simb√≥lico perfeito do mundo √© lento e propenso a erros, dificultando respostas em tempo real (o ‚Äúgargalo da modelagem‚Äù).

Arquitetura de Subsumption

AFSM: O sistema √© constru√≠do com M√°quinas de Estados Finitos Aumentadas (Augmented Finite State Machines) que executam em paralelo.

Supress√£o: Camadas de n√≠vel superior (por exemplo, ‚ÄúEvitar‚Äù) podem suprimir a entrada/sa√≠da de camadas inferiores (por exemplo, ‚ÄúExplorar‚Äù), garantindo que comportamentos de sobreviv√™ncia tenham prioridade.

Etologia ‚Äì Reflexos vs. FAP

Reflexo: A√ß√£o simples cuja dura√ß√£o √© aproximadamente igual √† dura√ß√£o do est√≠mulo (para quando o est√≠mulo para).

FAP (Fixed Action Pattern): Um est√≠mulo dispara uma sequ√™ncia de a√ß√µes que continua at√© o fim, mesmo que o est√≠mulo seja removido (execu√ß√£o em malha aberta).

Programa√ß√£o Orientada a Eventos (EDP)

Solu√ß√£o:
No ASEBA (Thymio), o loop principal normalmente √© vazio porque a arquitetura √© ass√≠ncrona. O c√≥digo depende de eventos (por exemplo, onevent prox, onevent timer) que disparam handlers espec√≠ficos. A CPU permanece em repouso ou executa tarefas de baixo n√≠vel at√© que um evento ocorra, maximizando a efici√™ncia.

Emerg√™ncia

Solu√ß√£o:
Comportamento emergente ocorre quando padr√µes globais complexos surgem da intera√ß√£o de regras locais simples e independentes, sem serem explicitamente programados.
Exemplo: comportamento de ‚Äúbando‚Äù (flocking) em enxames, onde cada rob√¥ segue regras simples como ‚Äúmanter dist√¢ncia‚Äù e ‚Äúigualar velocidade‚Äù.

Arquiteturas H√≠bridas

Solu√ß√£o:
Sistemas puramente comportamentais n√£o possuem mem√≥ria nem planejamento de longo prazo (‚Äúpresos ao agora‚Äù).
Arquiteturas h√≠bridas adicionam uma camada deliberativa (planejamento/mapas) sobre uma camada reativa (seguran√ßa/velocidade), permitindo planejamento √≥timo e gest√£o de sequ√™ncias complexas.

Estigmergia

Solu√ß√£o:
Estigmergia √© uma forma de coordena√ß√£o indireta em que agentes se comunicam modificando o ambiente.

Exemplo: Cupins construindo um ninho. Um deposita uma bola de lama/ferom√¥nio; essa modifica√ß√£o estimula outro a depositar lama no mesmo local, coordenando a constru√ß√£o sem comunica√ß√£o direta.

Intera√ß√£o Multi-Rob√¥: Liga√ß√µes Fracas vs. Fortes

Fracamente ligadas: Sem depend√™ncia m√∫tua estrita; se um falhar, os outros continuam (por exemplo, busca paralela).

Fortemente ligadas: Depend√™ncia m√∫tua; a tarefa falha se um membro falhar.

Exemplo: Dois rob√¥s carregando uma mesa pesada juntos.

Rob√≥tica de Enxame

Solu√ß√£o:

Propriedades: Controle distribu√≠do, aus√™ncia de hierarquia, sensoriamento e comunica√ß√£o locais.

Redund√¢ncia: Como todos os agentes s√£o simples e id√™nticos, se um falhar, outro pode substitu√≠-lo imediatamente. O desempenho degrada-se de forma gradual, em vez de colapsar.

Simula√ß√£o Rob√≥tica: Reality Gap

Solu√ß√£o:
O Reality Gap refere-se √† discrep√¢ncia entre o ambiente simulado e o mundo f√≠sico. Simuladores usam f√≠sica simplificada (modelos determin√≠sticos, atrito idealizado, sensores perfeitos). Um algoritmo que funciona na simula√ß√£o pode falhar no rob√¥ real devido a ru√≠do de sensores, derrapagem das rodas ou varia√ß√µes de ilumina√ß√£o n√£o modeladas.
